# -*- test-case-name: wokkel.test.test_server -*-
#
# Copyright (c) 2003-2008 Ralph Meijer
# See LICENSE for details.

"""
XMPP Server-to-Server protocol.

This module implements several aspects of XMPP server-to-server communications
as described in XMPP Core (RFC 3920). Refer to that document for the meaning
of the used terminology.
"""

# hashlib is new in Python 2.5, try that first.
try:
    from hashlib import sha256
except ImportError:
    from Crypto.Hash.SHA256 import new as sha256

import hmac

from zope.interface import implements

from twisted.application import service
from twisted.internet import defer, reactor
from twisted.names.srvconnect import SRVConnector
from twisted.python import log
from twisted.words.protocols.jabber import error, ijabber, jid, xmlstream
from twisted.words.xish import domish

from wokkel.generic import DeferredXmlStreamFactory, XmlPipe
from wokkel.compat import XmlStreamServerFactory

NS_DIALBACK = 'jabber:server:dialback'

def generateKey(secret, receivingServer, originatingServer, streamID):
    """
    Generate a dialback key for server-to-server XMPP Streams.

    The dialback key is generated using the algorithm described in
    U{XEP-0185<http://www.xmpp.org/extensions/xep-0185.html>}. The used
    terminology for the parameters is described in RFC-3920.

    @param secret: the shared secret known to the Originating Server and
                   Authoritive Server.
    @type secret: C{str}
    @param receivingServer: the Receiving Server host name.
    @type receivingServer: C{str}
    @param originatingServer: the Originating Server host name.
    @type originatingServer: C{str}
    @param streamID: the Stream ID as generated by the Receiving Server.
    @type streamID: C{str}
    @return: hexadecimal digest of the generated key.
    @type: C{str}
    """

    hashObject = sha256()
    hashObject.update(secret)
    hashedSecret = hashObject.hexdigest()
    message = " ".join([receivingServer, originatingServer, streamID])
    hash = hmac.HMAC(hashedSecret, message, digestmod=sha256)
    return hash.hexdigest()



class XMPPServerConnector(SRVConnector):
    def __init__(self, reactor, domain, factory):
        SRVConnector.__init__(self, reactor, 'xmpp-server', domain, factory)


    def pickServer(self):
        host, port = SRVConnector.pickServer(self)

        if not self.servers and not self.orderedServers:
            # no SRV record, fall back..
            port = 5269

        return host, port


class DialbackFailed(Exception):
    pass



class OriginatingDialbackInitializer(object):
    """
    Server Dialback Initializer for the Orginating Server.
    """

    implements(ijabber.IInitiatingInitializer)

    _deferred = None

    def __init__(self, xs, thisHost, otherHost, secret):
        self.xmlstream = xs
        self.thisHost = thisHost
        self.otherHost = otherHost
        self.secret = secret


    def initialize(self):
        self._deferred = defer.Deferred()
        self.xmlstream.addObserver(xmlstream.STREAM_ERROR_EVENT,
                                   self.onStreamError)
        self.xmlstream.addObserver("/result[@xmlns='%s']" % NS_DIALBACK,
                                   self.onResult)

        key = generateKey(self.secret, self.otherHost,
                          self.thisHost, self.xmlstream.sid)

        result = domish.Element((NS_DIALBACK, 'result'))
        result['from'] = self.thisHost
        result['to'] = self.otherHost
        result.addContent(key)

        self.xmlstream.send(result)

        return self._deferred


    def onResult(self, result):
        self.xmlstream.removeObserver(xmlstream.STREAM_ERROR_EVENT,
                                      self.onStreamError)
        if result['type'] == 'valid':
            self.xmlstream.otherEntity = jid.internJID(self.otherHost)
            self._deferred.callback(None)
        else:
            self._deferred.errback(DialbackFailed())


    def onStreamError(self, failure):
        self.xmlstream.removeObserver("/result[@xmlns='%s']" % NS_DIALBACK,
                                      self.onResult)
        self._deferred.errback(failure)



class ReceivingDialbackInitializer(object):
    """
    Server Dialback Initializer for the Receiving Server.
    """

    implements(ijabber.IInitiatingInitializer)

    _deferred = None

    def __init__(self, xs, thisHost, otherHost, originalStreamID, key):
        self.xmlstream = xs
        self.thisHost = thisHost
        self.otherHost = otherHost
        self.originalStreamID = originalStreamID
        self.key = key


    def initialize(self):
        self._deferred = defer.Deferred()
        self.xmlstream.addObserver(xmlstream.STREAM_ERROR_EVENT,
                                   self.onStreamError)
        self.xmlstream.addObserver("/verify[@xmlns='%s']" % NS_DIALBACK,
                                   self.onVerify)

        verify = domish.Element((NS_DIALBACK, 'verify'))
        verify['from'] = self.thisHost
        verify['to'] = self.otherHost
        verify['id'] = self.originalStreamID
        verify.addContent(self.key)

        self.xmlstream.send(verify)
        return self._deferred


    def onVerify(self, verify):
        self.xmlstream.removeObserver(xmlstream.STREAM_ERROR_EVENT,
                                      self.onStreamError)
        if verify['id'] != self.originalStreamID:
            self.xmlstream.sendStreamError(error.StreamError('invalid-id'))
            self._deferred.errback(DialbackFailed())
        elif verify['to'] != self.thisHost:
            self.xmlstream.sendStreamError(error.StreamError('host-unknown'))
            self._deferred.errback(DialbackFailed())
        elif verify['from'] != self.otherHost:
            self.xmlstream.sendStreamError(error.StreamError('invalid-from'))
            self._deferred.errback(DialbackFailed())
        elif verify['type'] == 'valid':
            self._deferred.callback(None)
        else:
            self._deferred.errback(DialbackFailed())


    def onStreamError(self, failure):
        self.xmlstream.removeObserver("/verify[@xmlns='%s']" % NS_DIALBACK,
                                      self.onVerify)
        self._deferred.errback(failure)



class XMPPServerConnectAuthenticator(xmlstream.ConnectAuthenticator):
    namespace = 'jabber:server'

    def __init__(self, thisHost, otherHost, secret):
        self.thisHost = thisHost
        self.otherHost = otherHost
        self.secret = secret
        xmlstream.ConnectAuthenticator.__init__(self, otherHost)


    def connectionMade(self):
        self.xmlstream.thisEntity = jid.internJID(self.thisHost)
        self.xmlstream.prefixes = {xmlstream.NS_STREAMS: 'stream',
                                   NS_DIALBACK: 'db'}
        xmlstream.ConnectAuthenticator.connectionMade(self)


    def associateWithStream(self, xs):
        xmlstream.ConnectAuthenticator.associateWithStream(self, xs)
        init = OriginatingDialbackInitializer(xs, self.thisHost,
                                              self.otherHost, self.secret)
        xs.initializers = [init]



class XMPPServerVerifyAuthenticator(xmlstream.ConnectAuthenticator):
    namespace = 'jabber:server'

    def __init__(self, thisHost, otherHost, originalStreamID, key):
        self.thisHost = thisHost
        self.otherHost = otherHost
        self.originalStreamID = originalStreamID
        self.key = key
        xmlstream.ConnectAuthenticator.__init__(self, otherHost)


    def connectionMade(self):
        self.xmlstream.thisEntity = jid.internJID(self.thisHost)
        self.xmlstream.prefixes = {xmlstream.NS_STREAMS: 'stream',
                                   NS_DIALBACK: 'db'}
        xmlstream.ConnectAuthenticator.connectionMade(self)


    def associateWithStream(self, xs):
        xmlstream.ConnectAuthenticator.associateWithStream(self, xs)
        init = ReceivingDialbackInitializer(xs, self.thisHost, self.otherHost,
                                            self.originalStreamID, self.key)
        xs.initializers = [init]



class XMPPServerListenAuthenticator(xmlstream.ListenAuthenticator):
    namespace = 'jabber:server'
    connectorClass = XMPPServerConnector

    def __init__(self, domain, secret):
        xmlstream.ListenAuthenticator.__init__(self)
        self.domain = domain
        self.secret = secret


    def streamStarted(self, rootElement):
        xmlstream.ListenAuthenticator.streamStarted(self, rootElement)

        self.xmlstream.namespace = self.namespace
        self.xmlstream.prefixes = {xmlstream.NS_STREAMS: 'stream',
                                   NS_DIALBACK: 'db'}
        self.xmlstream.thisEntity = jid.internJID(self.domain)
        self.xmlstream.sid = 'random' # FIXME

        try:
            if xmlstream.NS_STREAMS != rootElement.uri or \
               self.namespace != rootElement.defaultUri or \
               ('db', NS_DIALBACK) not in rootElement.localPrefixes.iteritems():
                raise error.StreamError('invalid-namespace')

            if rootElement.hasAttribute("to") and \
               rootElement["to"] != self.domain:
                raise error.StreamError('host-unknown')
        except error.StreamError, exc:
            self.xmlstream.sendStreamError(exc)
            return

        self.xmlstream.addObserver("//verify[@xmlns='%s']" % NS_DIALBACK,
                                   self.onVerify)
        self.xmlstream.addObserver("//result[@xmlns='%s']" % NS_DIALBACK,
                                   self.onResult)
        self.xmlstream.sendHeader()

        if self.xmlstream.version >= (1, 0):
            features = domish.Element((xmlstream.NS_STREAMS, 'features'))
            self.xmlstream.send(features)


    def onVerify(self, verify):
        receivingServer = verify.getAttribute('from')
        originatingServer = verify.getAttribute('to')
        streamID = verify.getAttribute('id')
        key = unicode(verify)

        if originatingServer != self.domain:
            self.xmlstream.sendStreamError(error.StreamError('host-unknown'))
            return
        #if receivingServer != ??:
        #    self.xmlstream.sendStreamError(error.StreamError('invalid-from'))
        #    return

        calculatedKey = generateKey(self.secret, receivingServer,
                                    originatingServer, streamID)
        validity = (key == calculatedKey) and 'valid' or 'invalid'

        reply = domish.Element((NS_DIALBACK, 'verify'))
        reply['from'] = originatingServer
        reply['to'] = receivingServer
        reply['id'] = streamID
        reply['type'] = validity
        self.xmlstream.send(reply)
        # self.xmlstream.sendFooter()


    def onResult(self, result):
        def connected(xs):
            self.verifyStream = xs

            def logDataIn(buf):
                log.msg("RECV!: %r" % buf)

            def logDataOut(buf):
                log.msg("SEND!: %r" % buf)

            xs.rawDataInFn = logDataIn
            xs.rawDataOutFn = logDataOut

        def reply(validity):
            factory.stopTrying()
            self.verifyStream.transport.loseConnection()
            self.verifyStream = None

            reply = domish.Element((NS_DIALBACK, 'result'))
            reply['from'] = result['to']
            reply['to'] = result['from']
            reply['type'] = validity
            self.xmlstream.send(reply)

        def valid(xs):
            reply('valid')
            self.xmlstream.otherEntity = jid.internJID(originatingServer)
            self.xmlstream.dispatch(self.xmlstream,
                                    xmlstream.STREAM_AUTHD_EVENT)

        def invalid(failure):
            reply('invalid')

        originatingServer = result['from']

        authenticator = XMPPServerVerifyAuthenticator(self.domain,
                                                      originatingServer,
                                                      self.xmlstream.sid,
                                                      unicode(result))
        factory = xmlstream.XmlStreamFactory(authenticator)
        factory.addBootstrap(xmlstream.STREAM_CONNECTED_EVENT, connected)
        factory.addBootstrap(xmlstream.STREAM_AUTHD_EVENT, valid)
        factory.addBootstrap(xmlstream.INIT_FAILED_EVENT, invalid)
        connector = self.connectorClass(reactor,
                                        originatingServer,
                                        factory)
        connector.connect()



class DeferredS2SClientFactory(DeferredXmlStreamFactory):
    """
    Deferred firing factory for initiating XMPP server-to-server connection.

    The deferred has its callbacks called upon succesful authentication with
    the other server. In case of failed authentication or connection, the
    deferred will have its errbacks called instead.
    """

    def __init__(self, domain, otherHost, secret):
        authenticator = XMPPServerConnectAuthenticator(domain,
                                                            otherHost,
                                                            secret)
        DeferredXmlStreamFactory.__init__(self, authenticator)



def initiateS2S(factory):
    domain = factory.authenticator.otherHost
    c = XMPPServerConnector(reactor, domain, factory)
    c.connect()
    return factory.deferred



class ServerService(service.Service):
    """
    Service for managing XMPP server to server connections.
    """

    logTraffic = False

    def __init__(self, router, domain, port=5222):
        self.router = router
        self.domain = domain
        self.port = port
        self.secret = 'woei!'

        def authenticatorFactory():
            return XMPPServerListenAuthenticator(self.domain, self.secret)
        self.factory = XmlStreamServerFactory(authenticatorFactory)
        self.factory.addBootstrap(xmlstream.STREAM_CONNECTED_EVENT,
                                  self.makeConnection)
        self.factory.addBootstrap(xmlstream.STREAM_AUTHD_EVENT,
                                  self.incomingInitialized)

        self.incomingStreams = {}
        self.outgoingStreams = {}
        self.outgoingQueues = {}
        self.outgoingConnecting = set()
        self.serial = 0


    def startService(self):
        pipe = XmlPipe()
        self.xmlstream = pipe.source
        self.router.addRoute(None, pipe.sink)
        self.xmlstream.addObserver('/*', self.send)

        service.Service.startService(self)
        reactor.listenTCP(self.port, self.factory)


    def makeConnection(self, xs):
        xs.serial = self.serial
        self.serial += 1

        def logDataIn(buf):
            log.msg("RECV (%d): %r" % (xs.serial, buf))

        def logDataOut(buf):
            log.msg("SEND (%d): %r" % (xs.serial, buf))

        if self.logTraffic:
            xs.rawDataInFn = logDataIn
            xs.rawDataOutFn = logDataOut


    def incomingInitialized(self, xs):
        self.incomingStreams[xs.otherEntity.host] = xs
        xs.addObserver(xmlstream.STREAM_END_EVENT,
                       lambda _: self.incomingDisconnected(xs))
        xs.addObserver('/*', lambda element: self.onElement(element, xs))


    def incomingDisconnected(self, xs):
        del self.incomingStreams[xs.otherEntity.host]


    def outgoingInitialized(self, xs):
        self.outgoingStreams[xs.otherEntity.host] = xs
        xs.addObserver(xmlstream.STREAM_END_EVENT,
                       lambda _: self.outgoingDisconnected(xs))

        if xs.otherEntity.host in self.outgoingQueues:
            print "Hier!"
            for element in self.outgoingQueues[xs.otherEntity.host]:
                xs.send(element)
            del self.outgoingQueues[xs.otherEntity.host]


    def outgoingDisconnected(self, xs):
        del self.outgoingStreams[xs.otherEntity.host]


    def initiateOutgoingStream(self, otherHost):
        if otherHost in self.outgoingConnecting:
            return

        factory = DeferredS2SClientFactory(self.domain,
                                           otherHost,
                                           self.secret)
        factory.addBootstrap(xmlstream.STREAM_CONNECTED_EVENT,
                             self.makeConnection)
        factory.addBootstrap(xmlstream.STREAM_AUTHD_EVENT,
                             self.outgoingInitialized)

        def resetConnecting(_):
            self.outgoingConnecting.remove(otherHost)

        d = initiateS2S(factory)
        def debug(result):
            print result
            return result
        d.addBoth(debug)
        d.addBoth(resetConnecting)
        self.outgoingConnecting.add(otherHost)


    def onElement(self, element, xs):
        """
        Called when an element was received from one of the connected streams.

        """
        if element.handled:
            return

        if jid.internJID(element["from"]).host != xs.otherEntity.host:
            xs.sendStreamError(error.StreamError('invalid-from'))
        else:
            self.xmlstream.send(element)


    def send(self, stanza):
        """
        Send stanza to the proper XML Stream.

        This uses addressing embedded in the stanza to find the correct stream
        to forward the stanza to.
        """

        destination = jid.internJID(stanza["to"]).host

        if destination not in self.outgoingStreams:
            # There is no connection with the destination (yet). Cache the
            # outgoing stanza until the connection has been established.
            # XXX: If the connection cannot be established, the queue should
            #      be emptied at some point.
            if destination not in self.outgoingQueues:
                self.outgoingQueues[destination] = []
            self.outgoingQueues[destination].append(stanza)
            self.initiateOutgoingStream(destination)
        else:
            self.outgoingStreams[destination].send(stanza)
